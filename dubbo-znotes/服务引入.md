##### 概述
1. 当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑
1. 按照惯例，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种：
	2. 第一种是引用本地 (JVM) 服务，
	2. 第二是通过直连方式引用远程服务，
	2. 第三是通过注册中心引用远程服务。
1. 不管是哪种引用方式，最后都会得到一个 Invoker 实例。
1. 如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。
1. 合并后的 Invoker 实例已经具备调用本地或远程服务的能力了
1. 此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。

##### 服务引入调用流程

0. spring容器调用 FactoryBeanRegistrySupport.java 中的 doGetObjectFromFactoryBean() 方法调用 RefrenceBean.java 中 getObject() 方法
    1. checkAndUpdateStubConfig()
    1. RefrenceConfig.java init()
        2. checkStubAndLocal(interfaceClass) // 检测接口与本地的impl（如果存在）是否是同一个接口
        2. checkMock(interfaceClass) // todo
        2. 初始化map  // todo 文档上更加详细
        	3. 如果不是泛化调用，获取该接口的 Wrapper 后方法列表，生成方法与exporter时一模一样。放入map中。 // methods: sayHello,ha
    		3. 获取 消费者 地址
        2. ref = createProxy(map)
        2. 将ref 赋值给 RefrenceConfig 成员变量
        	3. 如需要，从jvm中导入配置
        	3. 如需要，点对点直连
        	3. 加载注册中心，将 monitorUrl 放入map中，将map中参数以refer为key，放入每个url中。每个url的monitorUrl似乎不同。// todo refer参数的用处
        		4. 单个注册中心，interfaceClass, 注册中心url，即可生成 invoker 
        		4. 多个注册中心，对每个url 生成 invoker，将 invokers 放到 cluster中，变成invoker，便于调用。中间嵌套了 StaticDirectory 实例。
        			- 其中，如果注册中心url中，有 registry:// 开头，则xxxx，否则xxx 。url中肯定有 registry:// 啊！todo
        		4. 生成 invoker 过程如下：
        			5. 调用栈如下：
        				- Protocol$Adaptive.refer(interfaceClass类实例, 注册中心url) // 适配器
        				- ProtocolListenerWrapperWrapper.refer(interfaceClass类实例, 注册中心url)
        				- ProtocolFilterWrapper.refer(interfaceClass类实例, 注册中心url)
        				- RegistryProtocol.refer(interfaceClass类实例, 注册中心url)
        				6. RegistryProtocol.refer()
        					7. 如果 interfaceClass 就是 RegistryService 类型，todo
        					7. 如果 url 中含有 group 参数，则通过 SPI 加载 MergableCluster 实例
        					7. doRefer(cluster/MergableCluster实例, 注册中心实例, interfaceClassType, url)，该方法主要围绕 RegistryDirectory 实例展开
        						- 和 服务导出 时差不多，多了合并节点代码
        						8. 创建 RegistryDirectory 实例，设置注册中心和协议
        						8. 生成消费者链接
        						8. 去注册中心，添加节点，非订阅。registry.register(consumer url) // zk 上会有文件列表
        						8. 设置路由链(todo 先这么叫吧) directory.buildRouterChain(subcribeUrl)
	        						```
	        							consumer://10.75.16.91/org.apache.dubbo.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.2&interface=org.apache.dubbo.demo.DemoService&lazy=false&methods=sayHello,ha&pid=171368&qos.port=33333&side=consumer&sticky=false&timestamp=1575268725058
	    							```
        							9. 构造路由链 RouterChain.buildChain(url)
        								10. 通过 SPI 获取 RouterFactory 的 实现类实例（MockRouterFactory, TagRouterFactory, AppRouterFactory, ServiceRouterFactory）
        								10. 每个实现类实例，调用getRouter(url)。RouterChain.java
        									11.  // todo 
        								10. 将上面 router 添加到 List ，并排序 // todo，按照上面排序
        							----- 订阅url 调用 zk 的 CuratorFramework -----
    								9. 去 注册中心 订阅 url
    									10. 添加 this（RegistryDirectory实例）到 ConsumerConfigurationListener （static）中。就是个List
    									10. FailbackRegistry.subscribe(url, RegistryDirectory实例)
    										11. FailbackRegistry.duSubscribe(url, RegistryDirectory实例)
    											12. ZookeeperRegistry.doSubscribe(url, RegistryDirectory实例)
    												- Map<URL, ConcurrentMap<NotifyListener, ChildListener>> zkListeners
    												- ConcurrentMap<NotifyListener, ChildListener> listeners
    												- ChildListener zkListener
    												13. 根据 path 创建 zk 节点 zkClient.create(path)
    												13. 将 path，ChildListener 添加
    								----- 订阅url结束 -----
									9. 将 directory join 到 cluster 中，返回invoker。
			3. 为 invoker 生成代理，返回



        2. 根据服务名，ReferenceConfig，代理类构建 ConsumerModel ，并将其放入 ApplicationModel 之中
        ```
			new ConsumerModel(serviceKey, serviceInterface, ref, methods, attributes); // 
	        ApplicationModel.initConsumerModel()
        ```
    1. 初始化完成