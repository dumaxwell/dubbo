##### 消费端调用线程栈
  java.lang.Thread.State: RUNNABLE
	  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:134)
	  at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:177)
	  at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)
	  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:118)
	  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:84)
	  at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:80)
	  at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:97)
	  at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:155)
	  at org.apache.dubbo.rpc.protocol.AsyncToSyncInvoker.invoke(AsyncToSyncInvoker.java:52)
	  at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:92)
	  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:82)
	  at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:54)
	  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:82)
	  at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:60)
	  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:82)
	  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$CallbackRegistrationInvoker.invoke(ProtocolFilterWrapper.java:158)
	  at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:78)
	  at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)
	  at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:82)
	  at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:249)
	  at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:78)
	  at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:55)
	  at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)
	  at org.apache.dubbo.demo.consumer.Application.main(Application.java:28)

##### 调用栈
1. demoService.sayHello(str) -> org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1) 
	代理模式包装
	2. 调用 proxy0 中 invokerInvocationHandler.invoke(proxy, method, args) //第一个参数也没用
		3. 构造 Invocation ，new RpcInvocation(Method method, Object[] args)
		3. 调用 invokerInvocationHandler 中，invoker.invoke(invocation)
			4. 从 invoker 的 directory 中获取 url 参数 ：mock。MockClusterInvoker
				这里有3种取值：空 或者 false；true；其他
				5. 空 或者 false，则不使用 mock。调用 AbstractClusterInvoker 的 invoke()
					6. 检查 destroy 属性
					6. 绑定 RpcContext 的 attachments 到 invocation 中
					6. this.list(invocation) 
						从当前 invoker 的 directory 中获取所有可调用的 invokers
						7. abstractDirectory.list(invocation) // 
							8. this.doList(invocation) ->registryDirectory.doList(invocation)
								9. 检查 registry 属性 forbidden // 没有生产者，生产者调用不通 todo 这里和 invoker 中的 destroy 关联
								9. 遍历 registry 属性 routerChain，过滤 invoker
									10. 暂时有4中，过滤逻辑
					6. 返回 invokers 
					6. 加载 loadBalance 实例
						7. 获取 invokers 的第一个 invoker，读取 url 中 ${methodName}.loadBalance 参数。// todo 使用哪种负载均衡是生产者决定，且以方法为维度
						7. 加载上面获取的 loadBalance 实例。默认 random。
					6. RpcUtils.attachInvocationIdIfAsync()， 如果是异步调用，生产调用id，放到 invocation 中 // todo 异步调用
					6. ★ result = doInvoke() // 失败处理的 ClusterInvoker ，默认 FailoverClusterInvoker
						 以 FailoverClusterInvoker 为例，调用失败后，会尝试其他 invoker
						 7. 检查 invokers 可用
						 7. 获取 retry 次数
						 7. select(loadBalance) 依据当前负载均衡策略，获取一个 invoker
						 7. ★ InvokerWrapper.invoke(invocation) // todo 这一层看起来没用，但像一个分界点。这个 invoker 以内的 invoker 对应唯一一个生产者地址
						 	8. ListenerInvokerWrapper.invoke(invocation) // 
						 		9. ProtocolFilterWrapper$CallbackRegistrationInvoker
						 7. 倘若 这次调用 捕获到异常（消费者报的异常，生产者报的异常会保存在 Result 的属性中），循环 retry 次
				5. true，doMockInvoke()。调用mock方法 
					6. mock 分支
				5. 其他，则正常调用，抛异常后，再调用 doMockInvoke() 
		3. 返回 Result 。
		3. 对 Result 处理，recreate() todo 进方法看看，是哪个实现

##### 调用简述
1. 代理模式：实际调用代理对象
1. 调用 mock 逻辑，MockClusterInvoker 实现
1. 与所有生产者建立连接，验证服务可用性，路由过滤，返回可用的 invokers
1. 负载均衡，众多 invokers 中选出一个 invoker 
1. 如果该 invoker 调用失败，失败后策略（后话），retry等

