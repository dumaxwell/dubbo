##### 消费端调用线程栈
main:28, Application (org.apache.dubbo.demo.consumer)
sayHello:-1, proxy0 (org.apache.dubbo.common.bytecode)
invoke:55, InvokerInvocationHandler (org.apache.dubbo.rpc.proxy)

invoke:78, MockClusterInvoker (org.apache.dubbo.rpc.cluster.support.wrapper)
invoke:250, AbstractClusterInvoker (org.apache.dubbo.rpc.cluster.support)
doInvoke:82, FailoverClusterInvoker (org.apache.dubbo.rpc.cluster.support)

invoke:56, InvokerWrapper (org.apache.dubbo.rpc.protocol)

invoke:78, ListenerInvokerWrapper (org.apache.dubbo.rpc.listener)
invoke:158, ProtocolFilterWrapper$CallbackRegistrationInvoker (org.apache.dubbo.rpc.protocol)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:60, ConsumerContextFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:54, FutureFilter (org.apache.dubbo.rpc.protocol.dubbo.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:92, MonitorFilter (org.apache.dubbo.monitor.support)

invoke:52, AsyncToSyncInvoker (org.apache.dubbo.rpc.protocol)
invoke:155, AbstractInvoker (org.apache.dubbo.rpc.protocol)
doInvoke:98, DubboInvoker (org.apache.dubbo.rpc.protocol.dubbo)

request:80, ReferenceCountExchangeClient (org.apache.dubbo.rpc.protocol.dubbo)
request:84, HeaderExchangeClient (org.apache.dubbo.remoting.exchange.support.header)
request:118, HeaderExchangeChannel (org.apache.dubbo.remoting.exchange.support.header)

send:53, AbstractPeer (org.apache.dubbo.remoting.transport)
send:177, AbstractClient (org.apache.dubbo.remoting.transport)
send:134, NettyChannel (org.apache.dubbo.remoting.transport.netty4)

writeAndFlush:300, AbstractChannel (io.netty.channel)
writeAndFlush:1071, DefaultChannelPipeline (io.netty.channel)
writeAndFlush:831, AbstractChannelHandlerContext (io.netty.channel)
writeAndFlush:794, AbstractChannelHandlerContext (io.netty.channel)
write:825, AbstractChannelHandlerContext (io.netty.channel)
safeExecute:1007, AbstractChannelHandlerContext (io.netty.channel)
execute:760, SingleThreadEventExecutor (io.netty.util.concurrent)

##### 服务端handler线程栈
run:748, Thread (java.lang)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)

run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)
received:51, DecodeHandler (org.apache.dubbo.remoting.transport)
received:193, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)
handleRequest:102, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)

reply:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)

invoke:158, ProtocolFilterWrapper$CallbackRegistrationInvoker (org.apache.dubbo.rpc.protocol)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:149, GenericFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:105, ContextFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:81, TraceFilter (org.apache.dubbo.rpc.protocol.dubbo.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:48, TimeoutFilter (org.apache.dubbo.rpc.filter)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:92, MonitorFilter (org.apache.dubbo.monitor.support)
invoke:82, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)
invoke:55, ExceptionFilter (org.apache.dubbo.rpc.filter)

invoke:56, InvokerWrapper (org.apache.dubbo.rpc.protocol)
invoke:56, DelegateProviderMetaDataInvoker (org.apache.dubbo.config.invoker)

invoke:84, AbstractProxyInvoker (org.apache.dubbo.rpc.proxy)
doInvoke:48, JavassistProxyFactory$1 (org.apache.dubbo.rpc.proxy.javassist)
invokeMethod:-1, Wrapper1 (org.apache.dubbo.common.bytecode)
sayHello:33, DemoServiceImpl (org.apache.dubbo.demo.provider)

##### 服务端boss线程栈

##### 调用栈 todo 编码待看
1. demoService.sayHello(str) -> org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1) 
	代理模式包装
	2. 调用 proxy0 中 invokerInvocationHandler.invoke(proxy, method, args) //第一个参数也没用
		3. 构造 Invocation ，new RpcInvocation(Method method, Object[] args)
		3. 调用 invokerInvocationHandler 中，invoker.invoke(invocation)
			4. 从 invoker 的 directory 中获取 url 参数 ：mock。MockClusterInvoker
				这里有3种取值：空 或者 false；true；其他
				5. 空 或者 false，则不使用 mock。调用 AbstractClusterInvoker 的 invoke()
					6. 检查 destroy 属性
					6. 绑定 RpcContext 的 attachments 到 invocation 中
					6. this.list(invocation) 
						从当前 invoker 的 directory 中获取所有可调用的 invokers
						7. abstractDirectory.list(invocation) // 
							8. this.doList(invocation) ->registryDirectory.doList(invocation)
								9. 检查 registry 属性 forbidden // 没有生产者，生产者调用不通 todo 这里和 invoker 中的 destroy 关联
								9. 遍历 registry 属性 routerChain，过滤 invoker
									10. 暂时有4中，过滤逻辑
					6. 返回 invokers 
					6. 加载 loadBalance 实例
						7. 获取 invokers 的第一个 invoker，读取 url 中 ${methodName}.loadBalance 参数。// todo 使用哪种负载均衡是生产者决定，且以方法为维度
						7. 加载上面获取的 loadBalance 实例。默认 random。
					6. RpcUtils.attachInvocationIdIfAsync()， 如果是异步调用，生产调用id，放到 invocation 中 // todo 异步调用
					6. ★ result = doInvoke() // 失败处理的 ClusterInvoker ，默认 FailoverClusterInvoker
						 以 FailoverClusterInvoker 为例，调用失败后，会尝试其他 invoker
						 7. 检查 invokers 可用
						 7. 获取 retry 次数
						 7. select(loadBalance) 依据当前负载均衡策略，获取一个 invoker
						 7. ★ InvokerWrapper.invoke(invocation) // todo 这一层看起来没用，但像一个分界点。这个 invoker 以内的 invoker 对应唯一一个生产者地址
						 	8. ListenerInvokerWrapper.invoke(invocation) // 
						 		9. ProtocolFilterWrapper$CallbackRegistrationInvoker.invoke(invocation) // ListenerInvokerWrapper 的内部类

						 		----- 过滤链 -----
						 			10. ProtocolFilterWrapper$1.invoke(invocation) // ProtocolFilterWrapper$1 为过滤链实例，服务引入以过滤链赋值
						 				11. ConsumerContextFilter$1.invoke(next, invocation) // 由次进入 filter 的执行，入参变化
						 					12. 设置线程上下文
						 					12. ★ 调用下一层
						 					12. 调用结束后，删除上下文数据
						 				11. 若调用抛出异常，执行 Filter.Listener.onError(e, invoker, invocation) 处理异常
						 			10. ProtocolFilterWrapper$1.invoke(invocation)
						 				11. FutureFilter.invoke(invoker, invocation)
						 					12. todo 没执行，一会看
						 					12. ★ 调用下一层
						 			10. ProtocolFilterWrapper$1.invoke(invocation)
						 				11. MonitorFilter.invoker(invoker, invocation)
						 					12. 接口全路径 + 方法名 记录调用次数。重载的方法会合并计数
						 					12. ★ 调用下一层，AsyncToSyncInvoker.invoke(invocation)
						 		----- 过滤链 -----		
						 			 
						 						13. AbstractInvoker.invoke(invocation)
						 							14. 如果 destory ，抛异常
						 							14. 添加 invoker、RpcContext 中的 attachment 到 invocation 中。
						 							14. 添加 invoke mode（sync、async、future） 到 invocation
						 							14. 如果是异步，添加  invocation id 到 invocation
						 							14. ★ DubboInvoker.doInvoke(invocation)
						 								15. 获取 ExchangeClient currentClient
						 								15. ★ “单向”调用，currentClient.send(invocation)
						 								15. 返回 AsyncRpcResult.newDefaultAsyncResult(invocation) 。直接返回，无等待。
						 								15. ★ 带返回调用，responseFuture = currentClient.request(invocation, timeout)
						 									16. ReferenceCountExchangeClient.request(invocation, timeout)
						 										17. HeaderExchangeClient.request(invocation, timeout)
						 											18. HeaderExchangeChannel.request()
						 												19. remoting module req 设置 version、twoWay、data(请求体)
						 												19. new Future() // 包含超时检查 官方文档这里是老版本，这里同步、异步的区别在于，异步的是由用户线程调用 future 的.get()方法，同步则是由框架调用。
						 												19. AbstractPeer.send(req)
						 													20. AbstractClient.send(req) // [id: 0x5ee5e804, L:/10.75.16.91:65252 - R:/10.75.16.91:20880]
						 														21. void NettyChannel.send(req) 
						 															22. 检查 channel 是否关闭了
						 															22. ★ future = channel.writeAndFlush(req)
						 																23. netty 代码
						 																	----- ★ 服务端 -----
						 																	24. ★ NettyServerBoss 线程
						 																	24. ★ NettyServerWorker 线程
						 																	24. ★ DubboServerHandler 线程
						 																		25. ChannelEventRunnable.run() // implements Runnable
						 																			26. 判断 state == RECEIVED/SENT/CONNECTED/DISCONNECTED/CAUGHT
						 																			26. DecodeHandle.received(channel, req) // 这里是 RECEIVED
						 																				27. DecodeHandler.decode(req)
						 																					28. ((DecodeableRpcInvocation)req).decode()
						 																						29. this.decode(channel, inputStream)


						 																	----- ★ 服务端 -----
						 															22. future.await(timeout) // 调用完成或者超时，会调用 future.whenComplete 方法
						 								15. ★ result.subscribe(responseFuture) // 封装 future.whenComplete CompletableFuture.java


						 7. 倘若 这次调用 捕获到异常（消费者报的异常，生产者报的异常会保存在 Result 的属性中），循环 retry 次
				5. true，doMockInvoke()。调用mock方法 
					6. mock 分支
				5. 其他，则正常调用，抛异常后，再调用 doMockInvoke() 
		3. 返回 Result 。
		3. 对 Result 处理，recreate() todo 进方法看看，是哪个实现

##### 调用简述
1. 代理模式：实际调用代理对象
1. 调用 mock 逻辑，MockClusterInvoker 实现
1. 与所有生产者建立连接，验证服务可用性，路由过滤，返回可用的 invokers
1. 负载均衡，众多 invokers 中选出一个 invoker 
1. 如果该 invoker 调用失败，失败后策略（后话），retry等

